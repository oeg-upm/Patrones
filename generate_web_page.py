import argparse
import os
import sys
from app.source.detectPatterns.download_ontology import download_ontologies
from app.source.detectPatterns.create_structure import create_structure
from app.source.detectPatterns.identify_patterns import identify_patterns
from app.source.detectPatterns.infer_structures import infer_structures
from app.source.visualize_pattern.create_diagram import create_diagram
from app.source.generateFrontElements.generateFrontElements import generate_documentation

def main(ontology_path, csv_path, output_path, patterns_type, flatten_lists):
    
    # Check if the path specified in output_path exist and it is a directory
    # If the path does not exist, create the directory
    create_directory(output_path)

    # Create the directory where the data generated by this application is going to be stored
    data_path = os.path.join(output_path, 'data')
    create_directory(data_path)

    # Create the directory where the SVG images and the CSS is going to be stored
    web_path = os.path.join(output_path, 'web')
    create_directory(web_path)
    static_path = os.path.join(web_path, 'static')
    create_directory(static_path)
    images_path = os.path.join(static_path, 'images')
    create_directory(images_path)
    styles_path = os.path.join(static_path, 'styles')
    create_directory(styles_path)

    # Specify the files where the data generated by this application is going to be stored
    error_log_path = os.path.join(data_path, 'error_log.txt')
    structure_csv_path = os.path.join(data_path, 'Structure.csv')
    structure_type_path = os.path.join(data_path, 'Structure_term_type.txt')
    structure_name_path = os.path.join(data_path, 'Structure_term_name.txt')
    inferred_type_path = os.path.join(data_path, 'Structure_term_inferred_type.txt')
    inferred_blank_nodes_path = os.path.join(data_path, 'Structure_term_inferred_blank_nodes.txt')
    patterns_type_path = os.path.join(data_path, 'Patterns_type')
    patterns_name_path = os.path.join(data_path, 'Patterns_name')
    
    # Create the file where the logs will be stored 
    error_log = open(error_log_path , "w", encoding='utf-8')
    # Empty that file (in case the program has been executed before)
    error_log.truncate()

    # Check if the path specified in ontology_path exist and it is directory
    # If the path does not exist, create the directory
    create_directory(ontology_path)

    # Has the user specified the path to the CSV file indicating what ontologies are going to be downloaded?
    if csv_path != '':
        # Check if the CSV file exist
        check_csv_error(csv_path, error_log)
        # Download the ontologies specified in the CSV file
        download_ontologies(csv_path, ontology_path, error_log)

    # Cast the string given by the user to boolean
    flatten = True if flatten_lists == 'yes' else False

    # Create the files Structure.csv, Structure_term_type.txt and Structure_term_name.txt
    create_structure(ontology_path, error_log, flatten, structure_csv_path, structure_type_path, structure_name_path, False, None)
    # Create the files Structure_term_inferred_type.txt and Structure_term_inferred_blank_nodes.txt
    infer_structures(inferred_type_path, inferred_blank_nodes_path, structure_type_path, structure_name_path)

    # Has the user specified that the patterns are going to be created from the type of the terms?
    if patterns_type == 'type':
        # Create the files Patterns_type.csv and Patterns_type.txt
        identify_patterns(inferred_type_path, patterns_type_path, False, None)
        # Create the diagrams. The following files are going to be created:
        #   - For each pattern an SVG file is created with the representation of the pattern
        #   - An XML file with the representation of all the patterns
        create_diagram(f"{patterns_type_path}.txt", os.path.join(data_path, 'Visualization.xml'), images_path)
        generate_documentation(styles_path, patterns_type_path, inferred_blank_nodes_path, images_path, web_path, patterns_name_path, inferred_type_path)
    
    # Has the user specified that the patterns are going to be created from the name of the terms?
    elif patterns_type == 'name':
        # Create the files Patterns_name.csv and Patterns_name.txt
        identify_patterns(inferred_blank_nodes_path, patterns_name_path, False, None)
        #create_diagram(f"{patterns_name_path}.txt", os.path.join(data_path, 'Visualization.xml'), images_path)
        generate_documentation(styles_path, patterns_type_path, inferred_blank_nodes_path, images_path, web_path, patterns_name_path, inferred_type_path)
    
    else:
        # Create the files Patterns_type.csv and Patterns_type.txt
        identify_patterns(inferred_type_path, patterns_type_path, False, None)
        # Create the files Patterns_name.csv and Patterns_name.txt
        identify_patterns(inferred_blank_nodes_path, patterns_name_path, False, None)
        # Create the diagrams. The following files are going to be created:
        #   - For each pattern an SVG file is created with the representation of the pattern
        #   - An XML file with the representation of all the patterns
        create_diagram(f"{patterns_type_path}.txt", os.path.join(data_path, 'Visualization.xml'), images_path)
        # Create HTML and CSS files
        generate_documentation(styles_path, patterns_type_path, inferred_blank_nodes_path, images_path, web_path, patterns_name_path, inferred_type_path)
    
    error_log.close()

# Function to check if the path specified by the user is really a CSV file.
# If the path does not exist or the path is not a CSV file,
# the program will terminare witch code 1
def check_csv_error(csv_path, error_log):

    # Does the path given by the user not exist?
    if not os.path.exists(csv_path):
        error_log.write(f'The path {csv_path} to the CSV file indicating what ontologies are going to be downloaded does not exist.\nPlease enter a valid CSV file.\n')
        print(f'The path {csv_path} to the CSV file indicating what ontologies are going to be downloaded does not exist.\nPlease enter a valid CSV file.')
        error_log.close()
        sys.exit(1)

    # Is the path given by the user a file?
    elif not os.path.isfile(csv_path):
        error_log.write(f'The path {csv_path} to the CSV file indicating what ontologies are going to be downloaded exist but is not a file.\nPlease enter a valid CSV file.\n')
        print(f'The path {csv_path} to the CSV file indicating what ontologies are going to be downloaded exist but is not a file.\nPlease enter a valid CSV file.')
        error_log.close()
        sys.exit(1)
    
    # Is the path given by the user a CSV file?
    elif not csv_path.endswith('.csv'):
        error_log.write(f'The path {csv_path} to the CSV file indicating what ontologies are going to be downloaded exist but is not a CSV file.\nPlease enter a valid CSV file.\n')
        print(f'The path {csv_path} to the CSV file indicating what ontologies are going to be downloaded exist but is not a CSV file.\nPlease enter a valid CSV file.')
        error_log.close()
        sys.exit(1)

# Function to create a directory in the path specified by the user.
# If the directory could not be created or the path given by the user already exist and it is not a directory,
# the program will terminare witch code 1
def create_directory(dir_path):

    # Does the path given by the user not exist?
    if not os.path.exists(dir_path):

        # Create the directory
        try:
            os.mkdir(dir_path)

        except OSError as error:
            print(f'The directory could not be created in the path {dir_path}\nHere you have a hint of the problem:\n{error}')
            sys.exit(1)
    
    else:

        # Is the path given by the user not a directory?
        if not os.path.isdir(dir_path):
            print(f'The path {dir_path} already exists and it is not a directory\nPlease enter a valid directory.')
            sys.exit(1)

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Identify patterns from a set of ontologies')
    parser.add_argument('-ontology', '--ontology_path', 
                        type=str, 
                        help='Path to a folder where the ontologies are going to be downloaded. The patterns are going to be identified using the ontologies stored in this folder')
    parser.add_argument('-csv', '--csv_path', 
                        type=str, 
                        help='Path to the csv file indicating what ontologies are going to be downloaded',
                        default='')
    parser.add_argument('-output', '--output_path', 
                        type=str, 
                        help='Path to to a folder where the output of this application is going to be stored. If a path is not provided, the output is going to be stored in the current directory',
                        default='')
    parser.add_argument('-patterns', '--patterns_type', 
                        type=str, 
                        help='Flag to indicate if the patterns are going to be created from the type of the terms or from the name of the terms or from both',
                        choices=['type', 'name', 'both'],
                        default='type')
    parser.add_argument('-flatten', '--flatten_lists', 
                        type=str, 
                        help='Flag to indicate if the collections are going to be flatted if they just contain named classes',
                        choices=['yes', 'no'],
                        default='no')
    
    args = parser.parse_args()
    main(args.ontology_path, args.csv_path, args.output_path, args.patterns_type, args.flatten_lists)